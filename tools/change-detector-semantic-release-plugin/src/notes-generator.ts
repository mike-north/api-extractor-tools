/**
 * Release notes generator that adds API change details.
 *
 * @packageDocumentation
 */

import type {
  ASTComparisonReport,
  ClassifiedChange,
} from '@api-extractor-tools/change-detector'
import type {
  PluginConfig,
  SemanticReleaseContext,
  AnalysisResult,
} from './types'
import { resolveConfig } from './types'
import { getCachedAnalysis } from './plugin'
import { analyzeAPIChanges } from './analyzer'

/**
 * Generates release notes with API change details.
 *
 * This hook appends API change information to the release notes
 * generated by other plugins.
 *
 * @param pluginConfig - Plugin configuration
 * @param context - semantic-release context
 * @returns Additional release notes content, or empty string
 *
 * @alpha
 */
export function generateNotes(
  pluginConfig: PluginConfig,
  context: SemanticReleaseContext,
): string {
  const { cwd, logger, lastRelease } = context
  const config = resolveConfig(pluginConfig)

  // Skip if disabled
  if (!config.includeAPIChangesInNotes) {
    return ''
  }

  // Get analysis from cache or run fresh
  let analysis = getCachedAnalysis()
  if (!analysis) {
    analysis = analyzeAPIChanges(cwd, config, lastRelease)
  }

  // Skip if analysis failed or no changes
  if (analysis.error || analysis.recommendedBump === 'none') {
    return ''
  }

  // Handle new package
  if (analysis.isNewPackage) {
    return formatNewPackageNotes()
  }

  // Format API changes
  if (!analysis.report) {
    return ''
  }

  const notes = formatAPIChangesAsMarkdown(analysis.report)
  if (notes) {
    logger.log('Added API changes to release notes')
  }

  return notes
}

/**
 * Formats API changes as markdown for release notes.
 *
 * @param report - The comparison report
 * @returns Formatted markdown string
 *
 * @alpha
 */
export function formatAPIChangesAsMarkdown(
  report: ASTComparisonReport,
): string {
  const { byReleaseType, stats } = report
  const sections: string[] = []

  // Get all changes
  const breakingChanges = [...byReleaseType.forbidden, ...byReleaseType.major]
  const nonBreakingChanges = [...byReleaseType.minor, ...byReleaseType.patch]

  // Only include section if there are changes
  if (breakingChanges.length === 0 && nonBreakingChanges.length === 0) {
    return ''
  }

  sections.push('## API Changes')
  sections.push('')

  // Breaking changes section
  if (breakingChanges.length > 0) {
    sections.push('### Breaking Changes')
    sections.push('')
    sections.push(...formatChangesAsList(breakingChanges))
    sections.push('')
  }

  // Added exports
  const addedChanges = nonBreakingChanges.filter(
    (c) => c.descriptor.action === 'added',
  )
  if (addedChanges.length > 0) {
    sections.push('### Added Exports')
    sections.push('')
    sections.push(...formatAddedExports(addedChanges))
    sections.push('')
  }

  // Modified exports (non-breaking)
  const modifiedChanges = nonBreakingChanges.filter(
    (c) => c.descriptor.action !== 'added',
  )
  if (modifiedChanges.length > 0) {
    sections.push('### Modified Exports')
    sections.push('')
    sections.push(...formatChangesAsList(modifiedChanges))
    sections.push('')
  }

  // Summary stats
  sections.push('### Summary')
  sections.push('')
  sections.push(`- **Added**: ${stats.minor}`)
  sections.push(`- **Breaking**: ${stats.major + stats.forbidden}`)
  sections.push(`- **Other Changes**: ${stats.patch}`)
  sections.push('')

  return sections.join('\n')
}

/**
 * Formats a list of changes as markdown bullet points.
 */
function formatChangesAsList(changes: ClassifiedChange[]): string[] {
  const lines: string[] = []

  for (const change of changes) {
    const badge = getNodeKindBadge(change.nodeKind)
    lines.push(`- ${badge} \`${change.path}\`: ${change.explanation}`)

    // Add before/after if available and useful
    const before = change.oldNode?.typeInfo.signature
    const after = change.newNode?.typeInfo.signature
    if (before && after && change.descriptor.action !== 'removed') {
      // Truncate long signatures
      const beforeStr = truncateSignature(before)
      const afterStr = truncateSignature(after)
      if (beforeStr !== afterStr) {
        lines.push(`  - Before: \`${beforeStr}\``)
        lines.push(`  - After: \`${afterStr}\``)
      }
    }
  }

  return lines
}

/**
 * Formats added exports with their signatures.
 */
function formatAddedExports(changes: ClassifiedChange[]): string[] {
  const lines: string[] = []

  for (const change of changes) {
    const badge = getNodeKindBadge(change.nodeKind)
    const signature = change.newNode?.typeInfo.signature
    if (signature) {
      const truncated = truncateSignature(signature)
      lines.push(`- ${badge} \`${truncated}\``)
    } else {
      lines.push(`- ${badge} \`${change.path}\``)
    }
  }

  return lines
}

/**
 * Gets a badge/label for a node kind.
 */
function getNodeKindBadge(kind: ClassifiedChange['nodeKind']): string {
  const badges: Record<string, string> = {
    function: '**function**',
    class: '**class**',
    interface: '**interface**',
    'type-alias': '**type**',
    variable: '**const**',
    enum: '**enum**',
    namespace: '**namespace**',
    method: '**method**',
    property: '**property**',
  }
  return badges[kind] ?? kind
}

/**
 * Truncates a long signature to a reasonable length.
 */
function truncateSignature(signature: string, maxLength: number = 80): string {
  // Remove newlines and extra whitespace
  const normalized = signature.replace(/\s+/g, ' ').trim()

  if (normalized.length <= maxLength) {
    return normalized
  }

  return normalized.slice(0, maxLength - 3) + '...'
}

/**
 * Formats notes for a new package.
 */
function formatNewPackageNotes(): string {
  return [
    '## API Changes',
    '',
    'This is the initial release of this package.',
    '',
  ].join('\n')
}

/**
 * Generates a detailed description of API changes.
 * Useful for changeset summaries or detailed release notes.
 *
 * @param analysis - The analysis result
 * @returns A detailed description string
 *
 * @alpha
 */
export function generateDetailedDescription(analysis: AnalysisResult): string {
  if (analysis.isNewPackage) {
    return 'Initial release of package'
  }

  if (!analysis.report) {
    return ''
  }

  const { byReleaseType } = analysis.report
  const lines: string[] = []

  // Breaking changes
  const breakingChanges = [...byReleaseType.forbidden, ...byReleaseType.major]
  if (breakingChanges.length > 0) {
    lines.push('**Breaking Changes:**')
    for (const change of breakingChanges.slice(0, 5)) {
      lines.push(`- ${change.explanation}`)
    }
    if (breakingChanges.length > 5) {
      lines.push(`- ...and ${breakingChanges.length - 5} more`)
    }
    lines.push('')
  }

  // Non-breaking changes
  const nonBreakingChanges = [...byReleaseType.minor, ...byReleaseType.patch]
  if (nonBreakingChanges.length > 0) {
    lines.push('**New Features/Additions:**')
    for (const change of nonBreakingChanges.slice(0, 5)) {
      lines.push(`- ${change.explanation}`)
    }
    if (nonBreakingChanges.length > 5) {
      lines.push(`- ...and ${nonBreakingChanges.length - 5} more`)
    }
  }

  return lines.join('\n').trim()
}
