/**
 * Release notes generator that adds API change details.
 *
 * @packageDocumentation
 */

import type { ComparisonReport, Change } from '@api-extractor-tools/change-detector'
import type {
  PluginConfig,
  SemanticReleaseContext,
  AnalysisResult,
} from './types'
import { resolveConfig } from './types'
import { getCachedAnalysis } from './plugin'
import { analyzeAPIChanges } from './analyzer'

/**
 * Generates release notes with API change details.
 *
 * This hook appends API change information to the release notes
 * generated by other plugins.
 *
 * @param pluginConfig - Plugin configuration
 * @param context - semantic-release context
 * @returns Additional release notes content, or empty string
 *
 * @alpha
 */
export function generateNotes(
  pluginConfig: PluginConfig,
  context: SemanticReleaseContext,
): string {
  const { cwd, logger, lastRelease } = context
  const config = resolveConfig(pluginConfig)

  // Skip if disabled
  if (!config.includeAPIChangesInNotes) {
    return ''
  }

  // Get analysis from cache or run fresh
  let analysis = getCachedAnalysis()
  if (!analysis) {
    analysis = analyzeAPIChanges(cwd, config, lastRelease)
  }

  // Skip if analysis failed or no changes
  if (analysis.error || analysis.recommendedBump === 'none') {
    return ''
  }

  // Handle new package
  if (analysis.isNewPackage) {
    return formatNewPackageNotes()
  }

  // Format API changes
  if (!analysis.report) {
    return ''
  }

  const notes = formatAPIChangesAsMarkdown(analysis.report)
  if (notes) {
    logger.log('Added API changes to release notes')
  }

  return notes
}

/**
 * Formats API changes as markdown for release notes.
 *
 * @param report - The comparison report
 * @returns Formatted markdown string
 *
 * @alpha
 */
export function formatAPIChangesAsMarkdown(report: ComparisonReport): string {
  const { changes, stats } = report
  const sections: string[] = []

  // Only include section if there are changes
  if (
    changes.breaking.length === 0 &&
    changes.nonBreaking.length === 0
  ) {
    return ''
  }

  sections.push('## API Changes')
  sections.push('')

  // Breaking changes section
  if (changes.breaking.length > 0) {
    sections.push('### Breaking Changes')
    sections.push('')
    sections.push(...formatChangesAsList(changes.breaking))
    sections.push('')
  }

  // Added exports
  const addedChanges = changes.nonBreaking.filter(
    (c) => c.category === 'symbol-added',
  )
  if (addedChanges.length > 0) {
    sections.push('### Added Exports')
    sections.push('')
    sections.push(...formatAddedExports(addedChanges))
    sections.push('')
  }

  // Modified exports (non-breaking)
  const modifiedChanges = changes.nonBreaking.filter(
    (c) => c.category !== 'symbol-added',
  )
  if (modifiedChanges.length > 0) {
    sections.push('### Modified Exports')
    sections.push('')
    sections.push(...formatChangesAsList(modifiedChanges))
    sections.push('')
  }

  // Summary stats
  sections.push('### Summary')
  sections.push('')
  sections.push(`- **Added**: ${stats.added}`)
  sections.push(`- **Removed**: ${stats.removed}`)
  sections.push(`- **Modified**: ${stats.modified}`)
  sections.push('')

  return sections.join('\n')
}

/**
 * Formats a list of changes as markdown bullet points.
 */
function formatChangesAsList(changes: Change[]): string[] {
  const lines: string[] = []

  for (const change of changes) {
    const badge = getSymbolKindBadge(change.symbolKind)
    lines.push(`- ${badge} \`${change.symbolName}\`: ${change.explanation}`)

    // Add before/after if available and useful
    if (change.before && change.after && change.category !== 'symbol-removed') {
      // Truncate long signatures
      const before = truncateSignature(change.before)
      const after = truncateSignature(change.after)
      if (before !== after) {
        lines.push(`  - Before: \`${before}\``)
        lines.push(`  - After: \`${after}\``)
      }
    }
  }

  return lines
}

/**
 * Formats added exports with their signatures.
 */
function formatAddedExports(changes: Change[]): string[] {
  const lines: string[] = []

  for (const change of changes) {
    const badge = getSymbolKindBadge(change.symbolKind)
    if (change.after) {
      const signature = truncateSignature(change.after)
      lines.push(`- ${badge} \`${signature}\``)
    } else {
      lines.push(`- ${badge} \`${change.symbolName}\``)
    }
  }

  return lines
}

/**
 * Gets a badge/label for a symbol kind.
 */
function getSymbolKindBadge(kind: Change['symbolKind']): string {
  const badges: Record<Change['symbolKind'], string> = {
    function: '**function**',
    class: '**class**',
    interface: '**interface**',
    type: '**type**',
    variable: '**const**',
    enum: '**enum**',
    namespace: '**namespace**',
  }
  return badges[kind] ?? kind
}

/**
 * Truncates a long signature to a reasonable length.
 */
function truncateSignature(signature: string, maxLength: number = 80): string {
  // Remove newlines and extra whitespace
  const normalized = signature.replace(/\s+/g, ' ').trim()

  if (normalized.length <= maxLength) {
    return normalized
  }

  return normalized.slice(0, maxLength - 3) + '...'
}

/**
 * Formats notes for a new package.
 */
function formatNewPackageNotes(): string {
  return [
    '## API Changes',
    '',
    'This is the initial release of this package.',
    '',
  ].join('\n')
}

/**
 * Generates a detailed description of API changes.
 * Useful for changeset summaries or detailed release notes.
 *
 * @param analysis - The analysis result
 * @returns A detailed description string
 *
 * @alpha
 */
export function generateDetailedDescription(analysis: AnalysisResult): string {
  if (analysis.isNewPackage) {
    return 'Initial release of package'
  }

  if (!analysis.report) {
    return ''
  }

  const { changes } = analysis.report
  const lines: string[] = []

  // Breaking changes
  if (changes.breaking.length > 0) {
    lines.push('**Breaking Changes:**')
    for (const change of changes.breaking.slice(0, 5)) {
      lines.push(`- ${change.explanation}`)
    }
    if (changes.breaking.length > 5) {
      lines.push(`- ...and ${changes.breaking.length - 5} more`)
    }
    lines.push('')
  }

  // Non-breaking changes
  if (changes.nonBreaking.length > 0) {
    lines.push('**New Features/Additions:**')
    for (const change of changes.nonBreaking.slice(0, 5)) {
      lines.push(`- ${change.explanation}`)
    }
    if (changes.nonBreaking.length > 5) {
      lines.push(`- ...and ${changes.nonBreaking.length - 5} more`)
    }
  }

  return lines.join('\n').trim()
}
