<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@api-extractor-tools/change-detector-core](./change-detector-core.md) &gt; [decompileToPattern](./change-detector-core.decompiletopattern.md)

## decompileToPattern() function

> This API is provided as an alpha preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.
> 

Decompile a dimensional rule into pattern representation.

This function transforms low-level dimensional rules back into readable pattern templates. It uses a catalog of pattern mappings with confidence scoring to find the best representation.

The decompilation process: 1. Validates the input dimensional rule 2. Finds all pattern mappings that match the dimensions 3. Calculates confidence scores for each match 4. Returns the best match with alternatives

If no patterns match, it falls back to creating a generic pattern based on the action (e.g., "modified {<!-- -->target<!-- -->}<!-- -->").

**Signature:**

```typescript
export declare function decompileToPattern(dimensional: DimensionalRule): PatternDecompileResult;
```

## Parameters

<table><thead><tr><th>

Parameter


</th><th>

Type


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

dimensional


</td><td>

[DimensionalRule](./change-detector-core.dimensionalrule.md)


</td><td>

The dimensional rule to decompile


</td></tr>
</tbody></table>

**Returns:**

[PatternDecompileResult](./change-detector-core.patterndecompileresult.md)

Decompilation result with pattern, confidence, and alternatives

## Example 1

Basic decompilation

```typescript
const result = decompileToPattern({
  type: 'dimensional',
  action: ['removed'],
  target: ['export'],
  impact: ['narrowing'],
  returns: 'major'
})

if (result.success) {
  console.log(result.pattern?.template)    // 'removed {target}'
  console.log(result.confidence)           // ~0.8
  console.log(result.alternatives?.length) // 0-3 alternatives
}
```

## Example 2

Type change decompilation

```typescript
const result = decompileToPattern({
  type: 'dimensional',
  action: ['modified'],
  aspect: ['type'],
  impact: ['narrowing'],
  target: ['return-type'],
  returns: 'major'
})
// result.pattern.template = '{target} type narrowed'
// result.confidence â‰ˆ 0.9 (high due to aspect + impact match)
```

## Example 3

Fallback for unrecognized dimensions

```typescript
const result = decompileToPattern({
  type: 'dimensional',
  returns: 'patch'
  // No action, aspect, or target specified
})
// Falls back to 'modified {target}' with low confidence (0.2)
```

