## API Report File for "@api-extractor-tools/change-detector-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type * as ts from 'typescript';
import type { TSESTree } from '@typescript-eslint/typescript-estree';

// @alpha
export function adaptLegacyInputProcessorPlugin(legacy: InputProcessorPlugin): ChangeDetectorPlugin;

// Warning: (ae-forgotten-export) The symbol "ChangeDescriptorBase" needs to be exported by the entry point index.d.ts
//
// @alpha
export interface AddedDescriptor extends ChangeDescriptorBase {
    // (undocumented)
    action: 'added';
    // (undocumented)
    aspect?: never;
    // (undocumented)
    impact?: never;
}

// @alpha
export interface AnalyzableNode {
    astNode?: TSESTree.Node;
    children: Map<string, AnalyzableNode>;
    extends?: string[];
    implements?: string[];
    kind: NodeKind;
    location: SourceRange;
    metadata?: NodeMetadata;
    modifiers: Set<Modifier>;
    name: string;
    parent?: string;
    path: string;
    typeInfo: TypeInfo;
}

// @alpha
export function analyzeChanges(oldSource: string, newSource: string, tsModule: typeof ts, options?: AnalyzeChangesOptions): AnalyzeChangesResult;

// @alpha
export interface AnalyzeChangesOptions {
    diffOptions?: DiffOptions;
    parseOptions?: ParseOptions;
    policy?: Policy;
}

// @alpha
export interface AnalyzeChangesResult {
    changes: ApiChange[];
    releaseType: ReleaseType;
    results: ClassificationResult[];
}

// @alpha
export interface AnalyzedChange {
    after?: string;
    before?: string;
    category: ChangeCategory;
    // Warning: (ae-forgotten-export) The symbol "ChangeDetails" needs to be exported by the entry point index.d.ts
    details?: ChangeDetails;
    explanation: string;
    symbolKind: SymbolKind;
    symbolName: string;
}

// @alpha
export interface ApiChange {
    context: ChangeContext;
    descriptor: ChangeDescriptor;
    explanation: string;
    nestedChanges: ApiChange[];
    newLocation?: SourceRange;
    newNode?: AnalyzableNode;
    nodeKind: NodeKind;
    oldLocation?: SourceRange;
    oldNode?: AnalyzableNode;
    path: string;
}

// @alpha
export interface ASTAwareInputProcessor {
    processAST(content: string, filename?: string): Promise<ASTProcessResult> | ASTProcessResult;
}

// @alpha
export interface ASTAwarePolicyDefinition<TOptions extends ASTAwarePolicyOptions = ASTAwarePolicyOptions> extends Omit<PolicyDefinition<TOptions>, 'createPolicy'> {
    createPolicy(options?: TOptions): Policy;
    readonly requiresAST: true;
}

// @alpha
export interface ASTAwarePolicyOptions extends PolicyOptions {
    maxNestedDepth?: number;
    renamesAreBreaking?: boolean;
    severityOverrides?: Partial<Record<string, ReleaseType>>;
    treatNestedChangesAsMinor?: boolean;
}

// @alpha
export interface ASTAwareReporter {
    formatAST(report: ASTComparisonReport, options?: ASTAwareReporterOptions): Promise<string> | string;
}

// @alpha
export interface ASTAwareReporterDefinition<TOptions extends ASTAwareReporterOptions = ASTAwareReporterOptions> extends Omit<ReporterDefinition<TOptions>, 'createReporter'> {
    createReporter(options?: TOptions): ASTAwareReporter;
    readonly supportsAST: true;
}

// @alpha
export interface ASTAwareReporterOptions extends ReporterOptions {
    ast?: ASTReporterOptions;
}

// @alpha
export interface ASTCapability {
    applyPolicy(changes: ApiChange[], policy: Policy): ClassifiedChange[];
    compareModules(oldAnalysis: ModuleAnalysis, newAnalysis: ModuleAnalysis): ApiChange[];
}

// @alpha
export interface ASTChangeJSON {
    action: string;
    aspect?: string;
    changeKind: string;
    // (undocumented)
    explanation: string;
    impact?: string;
    // (undocumented)
    nestedChanges?: ASTChangeJSON[];
    // (undocumented)
    newLocation?: {
        start: {
            line: number;
            column: number;
        };
        end: {
            line: number;
            column: number;
        };
    };
    // (undocumented)
    newSignature?: string;
    // (undocumented)
    nodeKind: string;
    // (undocumented)
    oldLocation?: {
        start: {
            line: number;
            column: number;
        };
        end: {
            line: number;
            column: number;
        };
    };
    // (undocumented)
    oldSignature?: string;
    // (undocumented)
    path: string;
    // (undocumented)
    releaseType: ReleaseType;
    target: string;
}

// @alpha
export interface ASTComparisonReport {
    byReleaseType: Record<ReleaseType, ClassifiedChange[]>;
    changes: ClassifiedChange[];
    releaseType: ReleaseType;
    stats: {
        total: number;
        forbidden: number;
        major: number;
        minor: number;
        patch: number;
        none: number;
    };
}

// @alpha
export interface ASTParameterInfo {
    defaultValue?: string;
    location: SourceRange;
    name: string;
    normalizedName: string;
    optional: boolean;
    rest: boolean;
    type: string;
}

// @alpha
export interface ASTProcessResult {
    analysis: ModuleAnalysis;
    errors: string[];
}

// @alpha
export interface ASTReporterOptions {
    flattenNested?: boolean;
    includeLocations?: boolean;
    includeUnchanged?: boolean;
    maxDepth?: number;
    // (undocumented)
    newFilePath?: string;
    oldFilePath?: string;
    showDiff?: boolean;
    useColors?: boolean;
}

// @alpha
export interface ASTReportJSON {
    // (undocumented)
    changes: {
        forbidden: ASTChangeJSON[];
        major: ASTChangeJSON[];
        minor: ASTChangeJSON[];
        patch: ASTChangeJSON[];
        none: ASTChangeJSON[];
    };
    // (undocumented)
    releaseType: ReleaseType;
    // (undocumented)
    stats: {
        total: number;
        forbidden: number;
        major: number;
        minor: number;
        patch: number;
        none: number;
    };
}

// @alpha
export interface AsyncReporter {
    begin?(): Promise<ReportOutput | void>;
    end?(): Promise<ReportOutput | void>;
    format(report: ComparisonReport): Promise<ReportOutput>;
    formatChange?(change: Change): Promise<ReportOutput>;
}

// @alpha
export function calculatePatternConfidence(dimensional: DimensionalRule, pattern: PatternRule): number;

// @alpha
export interface Change extends AnalyzedChange {
    releaseType: ReleaseType;
}

// @alpha
export type ChangeAction = 'added' | 'removed' | 'modified' | 'renamed' | 'reordered';

// @alpha
export type ChangeAspect = 'type' | 'optionality' | 'readonly' | 'visibility' | 'abstractness' | 'staticness' | 'deprecation' | 'default-value' | 'constraint' | 'default-type' | 'enum-value' | 'extends-clause' | 'implements-clause';

// @alpha
export type ChangeCategory = 'symbol-removed' | 'symbol-added' | 'type-narrowed' | 'type-widened' | 'param-added-required' | 'param-added-optional' | 'param-removed' | 'param-order-changed' | 'return-type-changed' | 'signature-identical' | 'field-deprecated' | 'field-undeprecated' | 'field-renamed' | 'default-added' | 'default-removed' | 'default-changed' | 'optionality-loosened' | 'optionality-tightened' | 'enum-member-added' | 'enum-type-opened' | 'enum-type-closed';

// @alpha
export interface ChangeContext {
    ancestors: string[];
    depth: number;
    isNested: boolean;
    modifierChange?: {
        modifier: Modifier;
        direction: 'added' | 'removed';
    };
    newType?: string;
    oldType?: string;
    renameConfidence?: number;
}

// @alpha
export type ChangeDescriptor = AddedDescriptor | RemovedDescriptor | ModifiedDescriptor | RenamedDescriptor | ReorderedDescriptor;

// @alpha
export interface ChangeDetectorPlugin {
    readonly inputProcessors?: readonly InputProcessorDefinition[];
    readonly metadata: PluginMetadata;
    readonly policies?: readonly PolicyDefinition[];
    readonly reporters?: readonly ReporterDefinition[];
    readonly validators?: readonly ValidatorDefinition[];
}

// @alpha
export interface ChangeDetectorPluginWithLifecycle extends ChangeDetectorPlugin, PluginLifecycle {
}

// @alpha
export type ChangeImpact = 'widening' | 'narrowing' | 'equivalent' | 'unrelated' | 'undetermined';

// @alpha
export type ChangeMatcher = (change: ApiChange) => boolean;

// @alpha
export interface ChangesByImpact {
    breaking: Change[];
    forbidden: Change[];
    nonBreaking: Change[];
    unchanged: Change[];
}

// @alpha
export type ChangeTag = 'was-required' | 'now-required' | 'was-optional' | 'now-optional' | 'is-rest-parameter' | 'was-rest-parameter' | 'has-default' | 'had-default' | 'is-nested-change' | 'has-nested-changes' | 'affects-type-parameter';

// @alpha
export type ChangeTarget = 'export' | 'parameter' | 'return-type' | 'type-parameter' | 'property' | 'method' | 'enum-member' | 'index-signature' | 'constructor' | 'accessor';

// @alpha
export interface ClassificationResult extends ClassifiedChange {
    // @deprecated
    change: ApiChange;
}

// @alpha
export interface ClassifiedChange extends ApiChange {
    matchedRule?: {
        name?: string;
        description?: string;
    };
    releaseType: ReleaseType;
}

// @alpha
export function classifyChange(change: ApiChange, policy: Policy): ClassificationResult;

// @alpha
export function classifyChanges(changes: ApiChange[], policy: Policy): ClassificationResult[];

// @alpha
export interface ClassifyContext {
    newMetadata?: SymbolMetadata;
    oldMetadata?: SymbolMetadata;
}

// @alpha
export const COMMON_INTENTS: {
    readonly BREAKING_REMOVAL: IntentExpression;
    readonly BREAKING_RENAME: IntentExpression;
    readonly BREAKING_REQUIRED: IntentExpression;
    readonly BREAKING_NARROWING: IntentExpression;
    readonly SAFE_ADDITION: IntentExpression;
    readonly SAFE_OPTIONAL: IntentExpression;
    readonly SAFE_WIDENING: IntentExpression;
    readonly PATCH_DEPRECATION: IntentExpression;
};

// @alpha
export const COMMON_PATTERNS: {
    readonly EXPORT_REMOVAL: PatternTemplate;
    readonly MEMBER_REMOVAL: PatternTemplate;
    readonly REQUIRED_ADDITION: PatternTemplate;
    readonly OPTIONAL_ADDITION: PatternTemplate;
    readonly TYPE_NARROWING: PatternTemplate;
    readonly TYPE_WIDENING: PatternTemplate;
    readonly MADE_OPTIONAL: PatternTemplate;
    readonly MADE_REQUIRED: PatternTemplate;
    readonly DEPRECATION: PatternTemplate;
    readonly RENAME: PatternTemplate;
    readonly REORDER: PatternTemplate;
};

// @alpha
export interface ComparisonReport {
    changes: ChangesByImpact;
    newFile: string;
    oldFile: string;
    releaseType: ReleaseType;
    stats: ComparisonStats;
}

// @alpha
export interface ComparisonStats {
    added: number;
    modified: number;
    removed: number;
    totalSymbolsNew: number;
    totalSymbolsOld: number;
    unchanged: number;
}

// @alpha
export function compilePattern(pattern: PatternRule): PatternCompileResult;

// @alpha
export function createASTAwarePolicyDefinition<TOptions extends ASTAwarePolicyOptions = ASTAwarePolicyOptions>(definition: Omit<ASTAwarePolicyDefinition<TOptions>, 'requiresAST'>): ASTAwarePolicyDefinition<TOptions>;

// @alpha
export function createASTAwareReporterDefinition<TOptions extends ASTAwareReporterOptions = ASTAwareReporterOptions>(definition: Omit<ASTAwareReporterDefinition<TOptions>, 'supportsAST'>): ASTAwareReporterDefinition<TOptions>;

// @alpha
export function createASTComparisonReport(changes: ClassifiedChange[]): ASTComparisonReport;

// @alpha
export function createPluginRegistry(options?: PluginRegistryOptions): PluginRegistry;

// @alpha
export function createPolicy(name: string, defaultReleaseType: ReleaseType): PolicyBuilder;

// @alpha
export function createProgressivePolicy(): ProgressiveRuleBuilder;

// @alpha
export function createStandardPolicy(name: string, config?: {
    breakingRemovals?: boolean;
    safeAdditions?: boolean;
    deprecations?: boolean;
    typeNarrowing?: boolean;
    defaultReleaseType?: ReleaseType;
}): DSLPolicy;

// @alpha
export function decompileToPattern(dimensional: DimensionalRule): PatternDecompileResult;

// @alpha
export const defaultASTPolicy: ASTAwarePolicyDefinition;

// @alpha
export function detectCommonPattern(pattern: PatternRule): string | null;

// @alpha
export function detectParameterReordering(oldParams: ParameterInfo[], newParams: ParameterInfo[]): ParameterOrderAnalysis;

// @alpha
export function determineOverallRelease(results: ReadonlyArray<Pick<ClassifiedChange, 'releaseType'>>): ReleaseType;

// @alpha
export function diffModules(oldAnalysis: ModuleAnalysisWithTypes, newAnalysis: ModuleAnalysisWithTypes, options?: DiffOptions): ApiChange[];

// @alpha
export interface DiffOptions {
    detectParameterReordering?: boolean;
    includeNestedChanges?: boolean;
    maxNestingDepth?: number;
    renameThreshold?: number;
    resolveTypeRelationships?: boolean;
}

// @alpha
export interface DimensionalRule {
    action?: ChangeAction[];
    aspect?: ChangeAspect[];
    description?: string;
    impact?: ChangeImpact[];
    nested?: boolean;
    nodeKind?: NodeKind[];
    notTags?: ChangeTag[];
    returns: ReleaseType;
    tags?: ChangeTag[];
    target?: ChangeTarget[];
    type: 'dimensional';
}

// @alpha
export interface DiscoveredPlugin {
    readonly isLegacy: boolean;
    readonly keywords: readonly string[];
    readonly packageName: string;
    readonly packagePath: string;
    readonly packageVersion: string;
}

// @alpha
export interface DSLBuilderState {
    // (undocumented)
    currentLevel: 'intent' | 'pattern' | 'dimensional';
    // (undocumented)
    partialRule: Partial<DSLRule>;
    // (undocumented)
    validationErrors: DSLValidationError[];
}

// @alpha
export interface DSLPolicy {
    defaultReleaseType: ReleaseType;
    description?: string;
    name: string;
    rules: DSLRule[];
}

// @alpha
export type DSLRule = IntentRule | PatternRule | DimensionalRule;

// @alpha
export interface DSLValidationError {
    // (undocumented)
    code: string;
    // (undocumented)
    level: 'intent' | 'pattern' | 'dimensional';
    // (undocumented)
    location?: {
        line?: number;
        column?: number;
        expression?: string;
    };
    // (undocumented)
    message: string;
}

// @alpha
export interface DSLValidationResult {
    // (undocumented)
    errors: DSLValidationError[];
    // (undocumented)
    valid: boolean;
    // (undocumented)
    warnings: DSLValidationWarning[];
}

// @alpha
export interface DSLValidationWarning {
    // (undocumented)
    code: string;
    // (undocumented)
    level: 'intent' | 'pattern' | 'dimensional';
    // (undocumented)
    message: string;
    // (undocumented)
    suggestion?: string;
}

// @alpha
export function editDistance(a: string, b: string): number;

// @alpha
export interface EnumMemberInfo {
    hasExplicitValue: boolean;
    location: SourceRange;
    name: string;
    value: string | number | undefined;
}

// @alpha
export interface ExportedSymbol {
    kind: SymbolKind;
    metadata?: SymbolMetadata;
    name: string;
    signature: string;
    sourceLocation?: SourceLocation;
}

// @alpha
export interface ExtendedVersioningPolicy extends VersioningPolicy {
    classifyWithContext?(change: AnalyzedChange, context: PolicyContext): ReleaseType;
}

// @alpha
export function extractParameterInfo(sig: ts.Signature, checker: ts.TypeChecker, tsModule: typeof ts): ParameterInfo[];

// @alpha
export function findBestPattern(dimensional: DimensionalRule): string | null;

// @alpha
export function flattenChanges(changes: ApiChange[]): ApiChange[];

// @alpha
export function formatASTReportAsJSON(report: ASTComparisonReport, options?: ASTReporterOptions): ASTReportJSON;

// @alpha
export function formatASTReportAsMarkdown(report: ASTComparisonReport, options?: ASTReporterOptions): string;

// @alpha
export function formatASTReportAsText(report: ASTComparisonReport, options?: ASTReporterOptions): string;

// @alpha
export function formatSourceLocation(location: SourceRange | undefined, filePath?: string): string;

// @alpha
export function formatValidationErrors(result: PluginValidationResult, packageName?: string): string;

// @alpha
export function generateIntentExpression(pattern: PatternRule): string;

// @alpha
export function groupChangesByDescriptor(changes: ApiChange[]): Map<string, ApiChange[]>;

// @alpha
export type HybridPolicyDefinition<TOptions extends ASTAwarePolicyOptions = ASTAwarePolicyOptions> = PolicyDefinition<TOptions> | ASTAwarePolicyDefinition<TOptions>;

// @alpha
export function inferConstraints(pattern: PatternRule): Partial<DimensionalRule>;

// @alpha
export interface InputProcessor {
    process(content: string, filename?: string): Promise<ProcessResult> | ProcessResult;
}

// @alpha
export interface InputProcessorDefinition<TOptions extends InputProcessorOptions = InputProcessorOptions> {
    createProcessor(options?: TOptions): InputProcessor | Promise<InputProcessor>;
    readonly description?: string;
    readonly extensions: readonly string[];
    readonly id: string;
    readonly mimeTypes?: readonly string[];
    readonly name: string;
    readonly optionsSchema?: Record<string, unknown>;
}

// @alpha
export interface InputProcessorOptions {
    [key: string]: unknown;
}

// @alpha @deprecated
export interface InputProcessorPlugin {
    createProcessor(options?: unknown): InputProcessor;
    extensions: string[];
    id: string;
    name: string;
    version: string;
}

// @alpha
export type IntentExpression = 'breaking removal' | 'safe removal' | 'export removal is breaking' | 'member removal is breaking' | 'safe addition' | 'required addition is breaking' | 'optional addition is safe' | 'type narrowing is breaking' | 'type widening is safe' | 'type change is breaking' | 'making optional is breaking' | 'making required is breaking' | 'deprecation is patch' | 'rename is breaking' | 'reorder is breaking' | `${string} when ${string}` | `${string} unless ${string}`;

// @alpha
export interface IntentParseResult {
    errors?: string[];
    pattern?: PatternRule;
    success: boolean;
    suggestions?: string[];
}

// @alpha
export interface IntentRule {
    description?: string;
    expression: IntentExpression;
    returns: ReleaseType;
    type: 'intent';
}

// @alpha
export interface IntentSynthesisResult {
    alternatives?: IntentRule[];
    confidence: number;
    intent?: IntentRule;
    success: boolean;
}

// @alpha
export function interpretNameChange(oldName: string, newName: string, similarity: number): string;

// @alpha
export function isASTAwareInputProcessor(processor: unknown): processor is ASTAwareInputProcessor;

// @alpha
export function isASTAwarePolicyDefinition(def: HybridPolicyDefinition): def is ASTAwarePolicyDefinition;

// @alpha
export function isASTAwareReporterDefinition(def: ReporterDefinition | ASTAwareReporterDefinition): def is ASTAwareReporterDefinition;

// @alpha
export function isDimensionalRule(rule: DSLRule): rule is DimensionalRule;

// @alpha
export function isIntentRule(rule: DSLRule): rule is IntentRule;

// @alpha
export function isPatternRule(rule: DSLRule): rule is PatternRule;

// @alpha
export function isValidIntentExpression(expression: string): expression is IntentExpression;

// @alpha
export function isValidPatternTemplate(template: string): boolean;

// @alpha
export function isValidPlugin(plugin: unknown): plugin is ChangeDetectorPlugin;

// @alpha
export const jsonASTReporter: ASTAwareReporterDefinition;

// @alpha
export interface LoadedPlugin {
    readonly isLegacy: boolean;
    readonly package: PluginPackageInfo;
    readonly plugin: ChangeDetectorPlugin;
}

// @alpha
export const markdownASTReporter: ASTAwareReporterDefinition;

// @alpha
export interface ModifiedDescriptor extends ChangeDescriptorBase {
    // (undocumented)
    action: 'modified';
    aspect: ChangeAspect;
    impact: ChangeImpact;
}

// @alpha
export type Modifier = 'exported' | 'default-export' | 'readonly' | 'optional' | 'abstract' | 'static' | 'private' | 'protected' | 'public' | 'const' | 'declare' | 'async';

// @alpha
export interface ModuleAnalysis {
    errors: string[];
    exports: Map<string, AnalyzableNode>;
    filename: string;
    nodes: Map<string, AnalyzableNode>;
    source: string;
}

// @alpha
export interface ModuleAnalysisWithTypes extends ModuleAnalysis {
    checker: ts.TypeChecker;
    program: ts.Program;
    symbols: Map<string, ts.Symbol>;
}

// @alpha
export function nameSimilarity(a: string, b: string): number;

// @alpha
export type NodeKind = 'function' | 'class' | 'interface' | 'type-alias' | 'enum' | 'namespace' | 'variable' | 'property' | 'method' | 'parameter' | 'type-parameter' | 'enum-member' | 'call-signature' | 'construct-signature' | 'index-signature' | 'getter' | 'setter';

// @alpha
export interface NodeMetadata {
    defaultValue?: string;
    deprecated: boolean;
    deprecationMessage?: string;
    rawComment?: string;
}

// @alpha
export interface ParameterInfo {
    isOptional: boolean;
    isRest: boolean;
    name: string;
    position: number;
    type: string;
}

// @alpha
export interface ParameterOrderAnalysis {
    confidence: ReorderingConfidence;
    hasReordering: boolean;
    newParams: ParameterInfo[];
    oldParams: ParameterInfo[];
    positionAnalysis: ParameterPositionAnalysis[];
    summary: string;
}

// @alpha
export interface ParameterPositionAnalysis {
    interpretation: string;
    newName: string;
    oldName: string;
    position: number;
    similarity: number;
    type: string;
}

// @alpha
export interface ParseDeclarationResult {
    errors: string[];
    symbols: Map<string, ExportedSymbol>;
}

// @alpha
export function parseDeclarationString(content: string, _tsModule: typeof ts, _filename?: string): ParseDeclarationResult;

// @alpha
export function parseIntent(intent: IntentRule): IntentParseResult;

// @alpha
export function parseModule(source: string, options?: ParseOptions): ModuleAnalysis;

// @alpha
export function parseModuleWithTypes(source: string, tsModule: typeof ts, options?: ParseOptions): ModuleAnalysisWithTypes;

// @alpha
export interface ParseOptions {
    extractMetadata?: boolean;
    filename?: string;
    resolveTypes?: boolean;
}

// @alpha
export interface PatternCompileResult {
    dimensional?: DimensionalRule;
    errors?: string[];
    success: boolean;
    warnings?: string[];
}

// @alpha
export interface PatternDecompileResult {
    alternatives?: PatternRule[];
    confidence: number;
    pattern?: PatternRule;
    success: boolean;
}

// @alpha
export interface PatternRule {
    description?: string;
    returns: ReleaseType;
    template: PatternTemplate;
    type: 'pattern';
    variables: PatternVariable[];
}

// @alpha
export type PatternTemplate = 'added {target}' | 'removed {target}' | 'renamed {target}' | 'reordered {target}' | 'modified {target}' | 'added required {target}' | 'added optional {target}' | 'removed optional {target}' | '{target} type narrowed' | '{target} type widened' | '{target} made optional' | '{target} made required' | '{target} deprecated' | '{target} undeprecated' | '{pattern} when {condition}' | '{pattern} unless {condition}' | '{pattern} for {nodeKind}' | '{pattern} and {pattern}' | '{pattern} or {pattern}';

// @alpha
export interface PatternVariable {
    name: string;
    type: 'target' | 'nodeKind' | 'condition' | 'pattern';
    value: ChangeTarget | NodeKind;
}

// @alpha
export const PLUGIN_KEYWORDS: {
    readonly UNIFIED: "change-detector:plugin";
    readonly INPUT_PROCESSOR_LEGACY: "change-detector:input-processor-plugin";
};

// @alpha
export interface PluginDiscoveryError {
    readonly cause?: Error;
    readonly message: string;
    readonly packageName?: string;
    readonly packagePath?: string;
}

// @alpha
export interface PluginDiscoveryLogger {
    debug?(message: string): void;
    error(message: string): void;
    warn(message: string): void;
}

// @alpha
export interface PluginDiscoveryOptions {
    readonly includeLegacy?: boolean;
    readonly logger?: PluginDiscoveryLogger;
    readonly packageNames?: readonly string[];
    readonly searchPaths?: readonly string[];
    readonly validate?: boolean;
}

// @alpha
export interface PluginDiscoveryResult {
    readonly errors: readonly PluginDiscoveryError[];
    readonly plugins: readonly LoadedPlugin[];
    readonly skipped: readonly PluginPackageInfo[];
}

// @alpha
export class PluginError extends Error {
    constructor(code: PluginErrorCode, message: string, options?: {
        pluginId?: string;
        capabilityId?: string;
        cause?: Error;
    });
    readonly capabilityId?: string;
    readonly cause?: Error;
    readonly code: PluginErrorCode;
    readonly pluginId?: string;
}

// @alpha
export type PluginErrorCode = 'PLUGIN_LOAD_FAILED' | 'PLUGIN_INVALID_METADATA' | 'PLUGIN_CAPABILITY_NOT_FOUND' | 'PLUGIN_OPTIONS_INVALID' | 'PROCESSOR_PARSE_ERROR' | 'POLICY_CLASSIFICATION_ERROR' | 'REPORTER_FORMAT_ERROR' | 'VALIDATOR_ERROR';

// @alpha
export interface PluginLifecycle {
    dispose?(): Promise<void>;
    initialize?(): Promise<void>;
}

// @alpha
export interface PluginMetadata {
    readonly description?: string;
    readonly homepage?: string;
    readonly id: string;
    readonly name: string;
    readonly version: string;
}

// @alpha
export interface PluginPackageInfo {
    readonly isLegacy: boolean;
    readonly keywords: readonly string[];
    readonly main?: string;
    readonly packageName: string;
    readonly packagePath: string;
    readonly packageVersion: string;
}

// @alpha
export interface PluginRegistry {
    clear(): void;
    findInputProcessorsForExtension(extension: string): ReadonlyArray<ResolvedCapability<InputProcessorDefinition>>;
    findReportersForFormat(format: string): ReadonlyArray<ResolvedCapability<ReporterDefinition>>;
    getInputProcessor(id: string): ResolvedCapability<InputProcessorDefinition> | undefined;
    getPolicy(id: string): ResolvedCapability<PolicyDefinition> | undefined;
    getReporter(id: string): ResolvedCapability<ReporterDefinition> | undefined;
    getValidator(id: string): ResolvedCapability<ValidatorDefinition> | undefined;
    listInputProcessors(): ReadonlyArray<ResolvedCapability<InputProcessorDefinition>>;
    listPolicies(): ReadonlyArray<ResolvedCapability<PolicyDefinition>>;
    listReporters(): ReadonlyArray<ResolvedCapability<ReporterDefinition>>;
    listValidators(): ReadonlyArray<ResolvedCapability<ValidatorDefinition>>;
    readonly plugins: ReadonlyMap<string, ChangeDetectorPlugin>;
    register(plugin: ChangeDetectorPlugin, options?: RegisterOptions): void;
    unregister(pluginId: string): boolean;
}

// @alpha
export interface PluginRegistryOptions {
    readonly logger?: RegistryLogger;
}

// @alpha
export type PluginResult<T> = {
    readonly success: true;
    readonly value: T;
} | {
    readonly success: false;
    readonly error: PluginError;
};

// @alpha
export interface PluginValidationError {
    readonly message: string;
    readonly path: string;
    readonly pluginId?: string;
}

// @alpha
export interface PluginValidationOptions {
    readonly allowEmptyCapabilities?: boolean;
    readonly packageName?: string;
    readonly validateFactories?: boolean;
}

// @alpha
export interface PluginValidationResult {
    readonly errors: readonly PluginValidationError[];
    readonly valid: boolean;
    readonly warnings: readonly PluginValidationError[];
}

// @alpha
export interface Policy {
    defaultReleaseType: ReleaseType;
    name: string;
    rules: PolicyRule[];
}

// @alpha
export class PolicyBuilder {
    constructor(name: string, defaultReleaseType: ReleaseType);
    addRule(policyRule: PolicyRule): this;
    addRules(...rules: PolicyRule[]): this;
    build(): Policy;
}

// @alpha
export interface PolicyContext {
    readonly allChanges: readonly AnalyzedChange[];
    readonly changeIndex: number;
    readonly metadata?: Readonly<Record<string, unknown>>;
}

// @alpha
export interface PolicyDefinition<TOptions extends PolicyOptions = PolicyOptions> {
    createPolicy(options?: TOptions): VersioningPolicy | ExtendedVersioningPolicy;
    readonly description?: string;
    readonly id: string;
    readonly name: string;
    readonly optionsSchema?: Record<string, unknown>;
}

// @alpha
export interface PolicyOptions {
    // (undocumented)
    [key: string]: unknown;
}

// @alpha
export interface PolicyRule {
    matches: ChangeMatcher;
    name: string;
    rationale?: string;
    releaseType: ReleaseType;
}

// @alpha
export interface ProcessResult {
    errors: string[];
    sourceMapping?: SourceMapping;
    symbols: Map<string, ExportedSymbol>;
}

// @alpha
export class ProgressiveRuleBuilder {
    addDimensionalRule(rule: DimensionalRule): void;
    addRule(rule: DSLRule): this;
    build(name: string, defaultReleaseType: ReleaseType, description?: string): DSLPolicy;
    clear(): this;
    clone(): ProgressiveRuleBuilder;
    // Warning: (ae-forgotten-export) The symbol "DimensionalRuleBuilder" needs to be exported by the entry point index.d.ts
    dimensional(name: string): DimensionalRuleBuilder;
    getRules(): ReadonlyArray<DSLRule>;
    intent(expression: IntentExpression, returns: ReleaseType, description?: string): this;
    pattern(template: PatternTemplate, variables: Record<string, unknown>, returns: ReleaseType, description?: string): this;
    transform(options: TransformOptions): this;
}

// @alpha
export interface PropertyInfo {
    location: SourceRange;
    name: string;
    optional: boolean;
    readonly: boolean;
    type: string;
}

// @alpha
export const readOnlyASTPolicy: ASTAwarePolicyDefinition;

// @alpha
export interface RegisterOptions {
    readonly force?: boolean;
}

// @alpha
export interface RegistryLogger {
    debug?(message: string): void;
    warn(message: string): void;
}

// @alpha
export type ReleaseType = 'forbidden' | 'major' | 'minor' | 'patch' | 'none';

// @alpha
export interface RemovedDescriptor extends ChangeDescriptorBase {
    // (undocumented)
    action: 'removed';
    // (undocumented)
    aspect?: never;
    // (undocumented)
    impact?: never;
}

// @alpha
export interface RenamedDescriptor extends ChangeDescriptorBase {
    // (undocumented)
    action: 'renamed';
    // (undocumented)
    aspect?: never;
    // (undocumented)
    impact?: never;
}

// @alpha
export interface ReorderedDescriptor extends ChangeDescriptorBase {
    // (undocumented)
    action: 'reordered';
    // (undocumented)
    aspect?: never;
    // (undocumented)
    impact?: never;
}

// @alpha
export type ReorderingConfidence = 'high' | 'medium' | 'low';

// @alpha
export interface Reporter {
    begin?(): ReportOutput | void;
    end?(): ReportOutput | void;
    format(report: ComparisonReport): ReportOutput;
    formatChange?(change: Change): ReportOutput;
}

// @alpha
export interface ReporterDefinition<TOptions extends ReporterOptions = ReporterOptions> {
    createReporter(options?: TOptions): Reporter | AsyncReporter | Promise<Reporter | AsyncReporter>;
    readonly description?: string;
    readonly fileExtension?: string;
    readonly format: ReportOutputFormat;
    readonly id: string;
    readonly isAsync?: boolean;
    readonly name: string;
    readonly optionsSchema?: Record<string, unknown>;
}

// @alpha
export interface ReporterOptions {
    // (undocumented)
    [key: string]: unknown;
}

// @alpha
export type ReportOutput = {
    readonly format: 'text';
    readonly content: string;
} | {
    readonly format: 'markdown';
    readonly content: string;
} | {
    readonly format: 'json';
    readonly content: object;
} | {
    readonly format: 'html';
    readonly content: string;
} | {
    readonly format: 'custom';
    readonly content: string | object;
};

// @alpha
export type ReportOutputFormat = 'text' | 'markdown' | 'json' | 'html' | 'custom';

// @alpha
export interface ResolvedCapability<T> {
    readonly definition: T;
    readonly pluginId: string;
    readonly qualifiedId: string;
}

// @alpha
export interface ResolvedPlugin {
    readonly inputProcessors: ReadonlyMap<string, InputProcessorDefinition>;
    readonly plugin: ChangeDetectorPlugin | ChangeDetectorPluginWithLifecycle;
    readonly policies: ReadonlyMap<string, PolicyDefinition>;
    readonly reporters: ReadonlyMap<string, ReporterDefinition>;
    readonly source: DiscoveredPlugin;
    readonly validators: ReadonlyMap<string, ValidatorDefinition>;
}

// @alpha
export function rule(name: string): RuleBuilder;

// @alpha
export class RuleBuilder {
    constructor(name: string);
    action(...actions: ChangeAction[]): this;
    aspect(...aspects: ChangeAspect[]): this;
    hasAnyTag(...tags: ChangeTag[]): this;
    hasTag(...tags: ChangeTag[]): this;
    impact(...impacts: ChangeImpact[]): this;
    nested(isNested?: boolean): this;
    nodeKind(...kinds: NodeKind[]): this;
    notTag(...tags: ChangeTag[]): this;
    rationale(text: string): this;
    returns(releaseType: ReleaseType): PolicyRule;
    target(...targets: ChangeTarget[]): this;
    when(matcher: ChangeMatcher): this;
}

// @alpha
export const semverDefaultPolicy: Policy;

// @alpha
export const semverReadOnlyPolicy: Policy;

// @alpha
export const semverWriteOnlyPolicy: Policy;

// @alpha
export interface SignatureInfo {
    location: SourceRange;
    normalized: string;
    parameters: ASTParameterInfo[];
    returnType: string;
    typeParameters: TypeParameterInfo[];
}

// @alpha
export interface SourceLocation {
    column: number;
    endColumn?: number;
    endLine?: number;
    line: number;
}

// @alpha
export interface SourceMapping {
    sourceFile: string;
    symbolLocations: Map<string, SourceLocation>;
}

// @alpha
export interface SourcePosition {
    column: number;
    line: number;
    offset: number;
}

// @alpha
export interface SourceRange {
    end: SourcePosition;
    start: SourcePosition;
}

// @alpha
export function suggestIntentCorrections(expression: string): string[];

// @alpha
export type SymbolKind = 'function' | 'class' | 'interface' | 'type' | 'variable' | 'enum' | 'namespace';

// @alpha
export interface SymbolMetadata {
    defaultValue?: string;
    deprecationMessage?: string;
    enumType?: 'open' | 'closed';
    isDeprecated?: boolean;
    isReference?: boolean;
    referencedType?: string;
}

// @alpha
export function synthesizeIntent(pattern: PatternRule): IntentSynthesisResult;

// @alpha
export const textASTReporter: ASTAwareReporterDefinition;

// @alpha
export interface TransformationChain {
    confidence: number;
    intermediates: DSLRule[];
    lossyTransformations: string[];
    source: DSLRule;
    target: DSLRule;
}

// @alpha
export interface TransformOptions {
    preference?: 'readable' | 'precise' | 'compact';
    preserveMetadata?: boolean;
    targetLevel: 'intent' | 'pattern' | 'dimensional';
    validate?: boolean;
}

// @alpha
export interface TypeInfo {
    callSignatures?: SignatureInfo[];
    constructSignatures?: SignatureInfo[];
    intersectionMembers?: string[];
    // (undocumented)
    numberIndexType?: string;
    properties?: PropertyInfo[];
    raw: string;
    signature: string;
    stringIndexType?: string;
    typeParameters?: TypeParameterInfo[];
    unionMembers?: string[];
}

// @alpha
export interface TypeParameterInfo {
    constraint?: string;
    default?: string;
    location: SourceRange;
    name: string;
    normalizedName: string;
}

// @alpha
export function validatePlugin(plugin: unknown, options?: PluginValidationOptions): PluginValidationResult;

// @alpha
export interface ValidationResult {
    readonly errors: readonly string[];
    readonly valid: boolean;
    readonly warnings: readonly string[];
}

// @alpha
export interface Validator {
    validate(symbols: ReadonlyMap<string, ExportedSymbol>, source: string): ValidationResult;
}

// @alpha
export interface ValidatorDefinition<TOptions extends Record<string, unknown> = Record<string, unknown>> {
    createValidator(options?: TOptions): Validator;
    readonly description?: string;
    readonly id: string;
    readonly name: string;
}

// @alpha
export interface VersioningPolicy {
    classify(change: AnalyzedChange, context?: ClassifyContext): ReleaseType;
    readonly name: string;
}

// @alpha
export const writeOnlyASTPolicy: ASTAwarePolicyDefinition;

```
